What were the problems with early computing?
* Use of batch processing. limited feedback loop. and lack of best practices for implementing and producing programs.
  * I think batch processing has to do with scripts being run in "batches" instead of whenever a programmer felt like running a script or line of code. If a batch of code fails it may be impossible to know which time of code failed. In time-sharing, jobs are given a time and are often accompanied by an output. Takes advantage of human interaction. The limitation of having a limited feedback loop is directly related the batch processing versus time-sharing. All programmers were also using different philosophies and methodologies for approaching solving programming problems that there was a lot of confusion when attempting to scale up or take on large projects. It was basically like a bunch of hobbists coming together and realizing that they needed some structure if they wanted to be able to scale and sell the product of their hobby. Introduction of guidelines and best practices is what took computing from being a crapshoot someone did in their basement to a robust profession with a systematic approach for solving challenging problems. 

Why does engineering take creativity?
* Engineering is about finding solutions to problems. If the problem already had a simple solution, the person with the problem would just solve it and hire someone and tell them how to do it. Hiring an engineer mean that you don't have a solution and you need someone else to create one. It's important to note that many of todays problems already have solutions so in some sense many software engineers often are acting a bit like technicians. Many of the issues we commonly run into are design flaws and have already been solved. Engineering is about building a solution for a previously unencountered problem. It will be slightly different and thus require some level of creativity in finding a unique solution.

What is the engineering approach? Why can it be argued that the first two can be the most time consuming?
* Understand the problem and plan a solution
  * Understanding the problem is critical to being an effective engineer because it makes the engineer's job easier and the clients happier. You simply cannot solve a problem that you do not understand. Without understanding the problem, you may build the wrong solution which is a waste of time and is frustrating. It is important to ask lots of questions. Asking questions does not mean you are stupid. It means you don't understand. And not understanding something and being stupid are two different things. Don't make assumptions about what someone wants. Next you need to plan out your solution. Even if you understand the inputs and the expected outputs, the solution can still be very commplicated. Many of us mortals simply do not have the mental fortitude to keep all the moving parts in order. Write shit out and break it into small simple parts. Explain like I'm five (ELI5) could be a good rule of thumb. Most concepts are actually pretty simple when you reduce all the jargon, since you know, we're still trying to solve pretty basic human issues.
  
What does it mean to have user focused design?
* Your users are the ones that will be interacting with your product and expecting some kind of result. Whether it's entertainment, analysis, organization, productivity, they are expecting something based on some kind of input. It may make inuitive sense to you, the engineer and/or designer, but your users will likely not have your knowledge.

Why do I get so antsy doing this prepwork?
*  It's because you think you already know this stuff and you want to prove yourself and get a job. The reality is, you have to learn to do this stuff and do it effectively. Practice now and you won't feel so behind later. Planning fucking sucks, because it's slow and repetitive and seems intuitive to you. You already know all this stuff in your head and can thing at a million miles per hours and can organize everything in your head. That's great for small projects, but the projects that really matter are gigantic. You will literally have no idea what's going on and will probably never see some parts of the code. If someone didn't take the time to write down all of their thoughts, make a long-term plan, organize it, think through the appropriate solutions, you will have aboslutely no idea what's happening and will literally need to spend all your time basically reverse engineering the code to make it work. That's a huge waste of time. If for no other reason, do this prep stuff so that you don't fuck over your fellow engineers. So that you can build bigger projects. So that you don't get the middle finger when you ask for help. So that if you open source, other people can jump in and start helping right away. Honestly, it's often just the solving of the solution that's the fun part. Actually planning your solution, implementing it, and maintaining it is boring as fuck, but it's what you get paid for. 

Project managers are "management engineers".

Compare and contrast waterfall versus agile developement
* waterfall cascades from one step in the project to the next. You plan each of the steps out and do not move to the next one until the previous passes all of it's acceptance criteria. This is still useful today for large scale projects that do not need to respond quickly to consumer demands. This can mainly be for infrastructure projects. Spec(Understand the problem), design for solution, build your solution/product, test your product, deploy, maintain. Operating systems, bridges.
* Agile development is born out of the need to have a responsive product due to changing demands. It focuses on functionality and constantly queues the users for changes in needs. Agile is simply a reaction to the nature of the market and is mainly a management approach. If you're just in the role of the developer, you're still basically doing the same thing but in smaller chunks and will less understanding of the overall project. You may not get the satisfaction is seeing all of your work finally come together since you will likely be working on different chunks of the project at different times. It's kinda like interchangeable parts in manufacturing. It kinda takes away from the creativity of the design and turns you into more of a code monkey, but that's okay. If you don't want to be a shitty code monkey, get involved in the design process. Like I said, design is fun, coding is boring.

Important to note that while having more people in the design/solution process does not necssarily make the project move faster, having more coders once everything has been designed makes the coding go faster.
Maybe the better way to look at software engineering is that if done thoroughly, 80% of your total time spent will be on design and only spend 20% of your total time on coding. It's difficult to wrap your head around this because you think that more time coding means that you will finish faster, but you're really going to have to spend the same amount of time designing and you're just spending more time coding.

What are "user stories" and how are they helping in finding a solution?
It's important to note that eventhough we're not in the "design" section anymore we are always still talking about design. While you may have solved your user's problem at a high design level, you still need to apply design to your code to code effectively and efficiently. That is what "user stories" is about. It's about framing your users issues from their perspective so that you can eventually design appropriate solutions in the code. The user stories are not supposed to direct "how" the engineer solves this problem only "what" the user wants. Being able to write effective user stories mean that you also understand the overarching problem.

Whats the difference between "design" and "engineering" in regards to software development?
Design is generally more focused on how the user is interacting with the application. This leads it to have more focus on the front-end. Design looks at what the user's goals are and how to best get them there. This information is passed to the engineer who's job it is then "design" a solution that best meets these goals as outlined by the "designer". Software engineers will find that they often need to fill both roles but it is important to keep them separate and to not let the two diciplines merge too much.

Why is product testing important?
Product testing is like commenting. It doesn't seem necessary when your code is small and simple, but when your code starts getting larger and more complicated, it helps sort out headaches later down the time. Product testing and Test driven development is an approach to programming that ensures that parts of your code still pass functionality tests. There are many different kinds of coverage that I will not get into detail right now, but it stands to say that it is impossible given today's technology to test every bit of code all the time. There is simply not enough computational power at this time. That said, certain cases are going to be more important to test than others and depending on the design errors can be avoided completely. It is important to keep in mind that benefit of periodic testing as your code base grows to stay up with it. Kind of how it's easier to comment as you go rather than try to go back and comment everything at once. 

What is Service-Oriented Architecture?
SOA is the idea of building out your applications as independent applications with externalized APIs. This does not necessarily mean that all APIs are available to the public, but that modules within a larger system communicate via interfaces. This reduces the complexity of the whole system/application by reorgnizing the internal functional of the large scale app. So where you had a bunch of teams working on the whole application at once (for example Facebook), you break the whole structure into separate services and send teams to work on developing those separate systems, then you have one team working on redesigning and code the actual Facebook application that will take advantage of these different services via the API that your teams externalize. So really SOA is an organization restructing and rebuilding it's architecture to become a platform with more modularity. It's like a giant monolith company that decides the break apart into smaller departments/companies and each of the companies gets a new focus. Specialization and optimizing independently.



