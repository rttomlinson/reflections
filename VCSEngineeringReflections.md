What were the problems with early computing?
* Use of batch processing. limited feedback loop. and lack of best practices for implementing and producing programs.
  * I think batch processing has to do with scripts being run in "batches" instead of whenever a programmer felt like running a script or line of code. If a batch of code fails it may be impossible to know which time of code failed. In time-sharing, jobs are given a time and are often accompanied by an output. Takes advantage of human interaction. The limitation of having a limited feedback loop is directly related the batch processing versus time-sharing. All programmers were also using different philosophies and methodologies for approaching solving programming problems that there was a lot of confusion when attempting to scale up or take on large projects. It was basically like a bunch of hobbists coming together and realizing that they needed some structure if they wanted to be able to scale and sell the product of their hobby. Introduction of guidelines and best practices is what took computing from being a crapshoot someone did in their basement to a robust profession with a systematic approach for solving challenging problems. 

Why does engineering take creativity?
* Engineering is about finding solutions to problems. If the problem already had a simple solution, the person with the problem would just solve it and hire someone and tell them how to do it. Hiring an engineer mean that you don't have a solution and you need someone else to create one. It's important to note that many of todays problems already have solutions so in some sense many software engineers often are acting a bit like technicians. Many of the issues we commonly run into are design flaws and have already been solved. Engineering is about building a solution for a previously unencountered problem. It will be slightly different and thus require some level of creativity in finding a unique solution.

What is the engineering approach? Why can it be argued that the first two can be the most time consuming?
* Understand the problem and plan a solution
  * Understanding the problem is critical to being an effective engineer because it makes the engineer's job easier and the clients happier. You simply cannot solve a problem that you do not understand. Without understanding the problem, you may build the wrong solution which is a waste of time and is frustrating. It is important to ask lots of questions. Asking questions does not mean you are stupid. It means you don't understand. And not understanding something and being stupid are two different things. Don't make assumptions about what someone wants. Next you need to plan out your solution. Even if you understand the inputs and the expected outputs, the solution can still be very commplicated. Many of us mortals simply do not have the mental fortitude to keep all the moving parts in order. Write shit out and break it into small simple parts. Explain like I'm five (ELI5) could be a good rule of thumb. Most concepts are actually pretty simple when you reduce all the jargon, since you know, we're still trying to solve pretty basic human issues.
  
What does it mean to have user focused design?
* Your users are the ones that will be interacting with your product and expecting some kind of result. Whether it's entertainment, analysis, organization, productivity, they are expecting something based on some kind of input. It may make inuitive sense to you, the engineer and/or designer, but your users will likely not have your knowledge.

Why do I get so antsy doing this prepwork?
*  It's because you think you already know this stuff and you want to prove yourself and get a job. The reality is, you have to learn to do this stuff and do it effectively. Practice now and you won't feel so behind later. Planning fucking sucks, because it's slow and repetitive and seems intuitive to you. You already know all this stuff in your head and can thing at a million miles per hours and can organize everything in your head. That's great for small projects, but the projects that really matter are gigantic. You will literally have no idea what's going on and will probably never see some parts of the code. If someone didn't take the time to write down all of their thoughts, make a long-term plan, organize it, think through the appropriate solutions, you will have aboslutely no idea what's happening and will literally need to spend all your time basically reverse engineering the code to make it work. That's a huge waste of time. If for no other reason, do this prep stuff so that you don't fuck over your fellow engineers. So that you can build bigger projects. So that you don't get the middle finger when you ask for help. So that if you open source, other people can jump in and start helping right away. Honestly, it's often just the solving of the solution that's the fun part. Actually planning your solution, implementing it, and maintaining it is boring as fuck, but it's what you get paid for. 

